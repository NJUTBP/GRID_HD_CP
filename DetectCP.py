#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Mar 27 22:29:08 2023

@author: qianruixin
"""

import cpnet
from collections import Counter, defaultdict
import numpy as np
import networkx as nx 
import seaborn as sns
import matplotlib as mpl
from matplotlib import pyplot as plt
from sklearn.metrics import confusion_matrix, roc_curve, auc, accuracy_score

def GenerateGraph(Rs, LagRs, CutPos=0.01, CutNeg=-0.01):
    '''
    Use covariance matrix to generate a network

    Args:
        Rs: the covariance of neural activities
        LagRs: the covariance at 5s lag
        CutPos: the correlation (0 < r < CutPos) is set to 0
        CutNeg: the correlation (CutNeg < r < 0) is set to 0

    Reture:
        G: a network, where the node in the network corresponds to each 
        neuron and the edge corresponds to the temporal correlation between a cell pair.

    '''
    RsTemp = Rs - LagRs
    num_neurons = len(RsTemp)
    for n in range(num_neurons):   
        # Set the diagonal element to np.nan
        RsTemp[n, n] = np.nan
    aj = np.zeros((num_neurons, num_neurons)) # Adjacency Matrix
    pos_max = np.nanmax(RsTemp*(RsTemp > 0))
    pos_min = np.nanmin(RsTemp*(RsTemp > 0))
    neg_max = np.nanmax(RsTemp*(RsTemp < 0))
    neg_min = np.nanmin(RsTemp*(RsTemp < 0))
    
    for r in range(num_neurons):
        # There is no self-loop in the network
        IdxPos = np.argsort(RsTemp[r, :])[::-1][1:num_neurons]
        IdxNeg = np.argsort(RsTemp[r, :])[:num_neurons-1]
        for r2 in range(len(IdxPos)):
            if RsTemp[r, int(IdxPos[r2])] > CutPos:
                aj[r, int(IdxPos[r2])] = (RsTemp[r, int(IdxPos[r2])]-pos_min)/(pos_max-pos_min)
        for r2 in range(len(IdxNeg)):
            if RsTemp[r,int(IdxNeg[r2])] < CutNeg:
                aj[r,int(IdxNeg[r2])]=(neg_max-RsTemp[r, int(IdxNeg[r2])])/(neg_max-neg_min)
    
    xx, yy = np.nonzero(aj)  
    w = aj[xx, yy]
    edges = list(zip(xx, yy, w))        
    
    G=nx.Graph()
    G.add_nodes_from(np.arange((num_neurons)))
    G.add_weighted_edges_from(edges)
    
    return G

def CalCoreness(G):
    '''
    Use method (Rombach, M. P., et al, 2014) to calculate coreness scores of all nodes in the network

    Args:
        G: the network generated by the covariance matrix

    Reture:
        xlist_w: a list of coreness scores

    '''
    alist = np.arange(0.90,1.0+1e-3,0.02) # the size of score jump between the highest 
                                      # corness score and the lowest coreness score. a = 1: discret classification 
    blist = np.arange(0.5,0.7+1e-3,0.02) # the size of the core. b = 1: the number of nodes in the core = 0.
    xdict_w = {}
    for n in range(G.number_of_nodes()):
        xdict_w[n] = 0
    Qlist = []
    aalist = []
    bblist = []
    # the size of the core. b = 1: the number of nodes in the core = 0.
    for a in alist:
        for b in blist:
            print(a, b)
            alg = cpnet.Rombach(alpha=a, beta=b)
            alg.detect(G)
            Q = alg.Q_
            x = alg.get_coreness() 
            Qlist.append(Q)
            aalist.append(a)
            bblist.append(b)
            for n in range(G.number_of_nodes()): 
                xdict_w[n] += Q * x[n] 
    # the coreness score is a wieighted average across all parameters            
    xlist_w = []
    for n in range(G.number_of_nodes()):
        xlist_w.append(xdict_w[n] / sum(Qlist))
    return xlist_w

def Metrics(y_true, y_prob, threshold):
    """
    Calculate accuracy, precision, recall, and AUC for binary classification task.

    Args:
        y_true: array-like of shape (n_samples,)
            Ground truth labels.
        y_prob: array-like of shape (n_samples,)
            Predicted probabilities of the positive class.
        threshold: float
            Binary classification threshold.

    Reture:
        accuracy: The ratio of correctly predicted samples to the total number of samples.
        precision: The ratio of correctly predicted positive samples to the total number of predicted positive samples.
        recall: The ratio of correctly predicted positive samples to the total number of actual positive samples.
        auc_score:  The area under the Receiver Operating Characteristic (ROC) curve. It measures the ability of the 
        classifier to distinguish between positive and negative samples, over all possible classification thresholds. 
    """
    y_prob = np.array(y_prob)
    y_pred = (y_prob >= threshold).astype(int)
    tn, fp, fn, tp = confusion_matrix(y_true, y_pred).ravel()
    accuracy = accuracy_score(y_true, y_pred)
    precision = tp / (tp + fp) if tp + fp > 0 else 0
    recall = tp / (tp + fn) if tp + fn > 0 else 0
    fpr, tpr, _ = roc_curve(y_true, y_prob)
    auc_score = auc(fpr, tpr)
    return accuracy, precision, recall, auc_score

def set_node_colors(c, x, xstd, cmap, colored_nodes):

    node_colors = defaultdict(lambda x: "#8d8d8d")
    node_edge_colors = defaultdict(lambda xstd: "#4d4d4d")

    cnt = Counter([c[d] for d in colored_nodes])
    num_groups = len(cnt)

    # Set up the palette
    if cmap is None:
        if num_groups <= 10:
            cmap = sns.color_palette().as_hex()
        elif num_groups <= 20:
            cmap = sns.color_palette("tab20").as_hex()
        else:
            cmap = sns.color_palette("hls", num_groups).as_hex()

    # Calc size of groups
    cmap = dict(
        zip(
            [d[0] for d in cnt.most_common(num_groups)],
            [cmap[i] for i in range(num_groups)],
        )
    )
    bounds = np.linspace(0, 1, 11)
    norm = mpl.colors.BoundaryNorm(bounds, ncolors=12, extend="both")

    # Calculate the color for each node using the palette
    cmap_coreness = {
        k: sns.light_palette(v, n_colors=12).as_hex() for k, v in cmap.items()
    }
    cmap_coreness_dark = {
        k: sns.dark_palette(v, n_colors=12).as_hex() for k, v in cmap.items()
    }
    cmap = plt.get_cmap('tab10')
    colors_tab10 = cmap.colors #discret
    for d in colored_nodes:
        node_colors[d] = cmap_coreness[c[d]][norm(x[d]) - 1]
        if xstd[d] == 1:
            node_edge_colors[d] = 'purple' #purple
        elif xstd[d] == 2:
            node_edge_colors[d] = 'orange'
        elif xstd[d] == 3:
            node_edge_colors[d] = colors_tab10[6] #'pink'
        elif xstd[d] == 4:
            node_edge_colors[d] = 'green'
        else:
            node_edge_colors[d] = 'grey'
        # node_edge_colors[d] = cmap_coreness_dark[c[d]][-norm(xstd[d])]
    return node_colors, node_edge_colors

def calc_node_pos(G, layout_algorithm):
    if layout_algorithm is None:
        return nx.spring_layout(G)
    else:
        return layout_algorithm(G)

def classify_nodes(G, c, x, max_num=None):
    non_residuals = [d for d in G.nodes() if (c[d] is not None) and (x[d] is not None)]
    residuals = [d for d in G.nodes() if (c[d] is None) or (x[d] is None)]

    # Count the number of groups
    cnt = Counter([c[d] for d in non_residuals])
    cvals = np.array([d[0] for d in cnt.most_common(len(cnt))])

    if max_num is not None:
        cvals = set(cvals[:max_num])
    else:
        cvals = set(cvals)

    #
    colored_nodes = [d for d in non_residuals if c[d] in cvals]
    muted = [d for d in non_residuals if not c[d] in cvals]

    # Bring core nodes to front
    order = np.argsort([x[d] for d in colored_nodes])
    colored_nodes = [colored_nodes[d] for d in order]

    return colored_nodes, muted, residuals

def DrawNetwork(
    G,
    c,
    x,
    xstd,
    ax,
    draw_edge=True,
    l=0,
    colored_nodes=None,
    pos=None,
    cmap=None,
    max_group_num=None,
    font_size=0,
    labels=None,
    node_edgecolors=None,
    draw_nodes_kwd={"linewidths":1},
    draw_edges_kwd={"edge_color": "#adadad"},
    draw_labels_kwd={},
    layout_algorithm=None,
):
    """Plot the core-periphery structure in the networks.
    :param G: Graph
    :type G:  networkx.Graph
    :param c: dict
    :type c: group membership c[i] of i
    :param x: core (x[i])=1 or periphery (x[i]=0)
    :type x: dict
    :param ax: axis
    :type ax: matplotlib.pyplot.ax
    :param draw_edge: whether to draw edges, defaults to True
    :type draw_edge: bool, optional
    :param font_size: font size for node labels, defaults to 0
    :type font_size: int, optional
    :param pos: pos[i] is the xy coordinate of node i, defaults to None
    :type pos: dict, optional
    :param cmap: colomap defaults to None
    :type cmap: matplotlib.cmap, optional
    :param max_group_num: Number of groups to color, defaults to None
    :type max_group_num: int, optional
    :param draw_nodes_kwd: Parameter for networkx.draw_networkx_nodes, defaults to {}
    :type draw_nodes_kwd: dict, optional
    :param draw_edges_kwd: Parameter for networkx.draw_networkx_edges, defaults to {"edge_color": "#adadad"}
    :type draw_edges_kwd: dict, optional
    :param draw_labels_kwd: Parameter for networkx.draw_networkx_labels, defaults to {}
    :type draw_labels_kwd: dict, optional
    :param layout_kwd: layout keywords, defaults to {}
    :type layout_kwd: dict, optional
    :return: (ax, pos)
    :rtype: matplotlib.pyplot.ax, dict
    """
    if colored_nodes == None:
        # Split node into residual and non-residual
        colored_nodes, muted_nodes, residuals = classify_nodes(G, c, x, max_group_num)
        print(residuals)
    
        node_colors, node_edge_colors = set_node_colors(c, x, xstd, cmap, colored_nodes)
    
        # Set the position of nodes
        if pos is None:
            pos = calc_node_pos(G, layout_algorithm)
    
        # Draw
        nodes = nx.draw_networkx_nodes(
            G,
            pos,
            node_color=[node_colors[d] for d in colored_nodes],
            nodelist=colored_nodes,
            ax=ax,
            # zorder=3,
            **draw_nodes_kwd
        )
        nodes.set_linewidth(draw_nodes_kwd['linewidths'])
        if nodes is not None:
            nodes.set_zorder(3)
            nodes.set_edgecolor([node_edge_colors[r] for r in colored_nodes])
            nodes.set_linewidth(draw_nodes_kwd['linewidths'])
    
        draw_nodes_kwd_residual = draw_nodes_kwd.copy()
        draw_nodes_kwd_residual["node_size"] = 0.1 * draw_nodes_kwd.get("node_size", 100)
        nodes = nx.draw_networkx_nodes(
            G,
            pos,
            node_color="#efefef",
            nodelist=residuals,
            node_shape="s",
            ax=ax,
            **draw_nodes_kwd_residual
        )
        if nodes is not None:
            nodes.set_zorder(1)
            nodes.set_edgecolor("#4d4d4d")
    
        if draw_edge:
            threshold = 0.2  # 设置阈值
            edges_to_draw = [(u, v) for u, v, d in G.edges(data=True) if d['weight'] > threshold]
    
            nx.draw_networkx_edges(
                G.subgraph(colored_nodes + residuals), pos, edgelist=edges_to_draw, ax=ax, **draw_edges_kwd
            )
    
        if font_size > 0:
            nx.draw_networkx_labels(G, pos, ax=ax, font_size=font_size, labels=labels, **draw_labels_kwd)
    
        ax.axis("off")
    else:
        residuals = []
        node_colors, node_edge_colors = set_node_colors(c, x, xstd, cmap, colored_nodes)
        # Set the position of nodes
        if pos is None:
            pos = calc_node_pos(G, layout_algorithm)
    
        # Draw
        nodes = nx.draw_networkx_nodes(
            G,
            pos,
            node_color=[node_colors[d] for d in colored_nodes],
            nodelist=colored_nodes,
            ax=ax,
            # zorder=3,
            **draw_nodes_kwd
        )
        if nodes is not None:
            nodes.set_zorder(3)
            nodes.set_edgecolor([node_edge_colors[r] for r in colored_nodes])
            nodes.set_linewidth(3.0)
            nodes.set_linewidth(draw_nodes_kwd['linewidths'])
        draw_nodes_kwd_residual = draw_nodes_kwd.copy()
        draw_nodes_kwd_residual["node_size"] = 0.1 * draw_nodes_kwd.get("node_size", 100)
        nodes = nx.draw_networkx_nodes(
            G,
            pos,
            node_color="#efefef",
            nodelist=residuals,
            node_shape="s",
            ax=ax,
            **draw_nodes_kwd_residual
        )
        if nodes is not None:
            nodes.set_zorder(1)
            nodes.set_edgecolor("#4d4d4d")
    
        if draw_edge:
            nx.draw_networkx_edges(
                G.subgraph(colored_nodes + residuals), pos, ax=ax, **draw_edges_kwd
            )
    
        if font_size > 0:
            nx.draw_networkx_labels(G, pos, ax=ax, font_size=font_size, labels=labels, **draw_labels_kwd)
    
        ax.axis("off")        

    return ax, pos
